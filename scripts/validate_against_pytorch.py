#!/usr/bin/env python3
"""Validate JAX model outputs against PyTorch reference fixtures.

Loads ``.npz`` fixtures generated by ``generate_pt_fixtures.py`` and compares
them against outputs from the JAX DreamZero model.

Usage
-----
With converted Flax checkpoint::

    uv run python scripts/validate_against_pytorch.py \\
        --fixtures-dir fixtures/pt_reference/ \\
        --checkpoint path/to/flax_ckpt

Without checkpoint (uses random weights — only validates shapes and
non-NaN outputs)::

    uv run python scripts/validate_against_pytorch.py \\
        --fixtures-dir fixtures/pt_reference/

See ``--help`` for all options.
"""

from __future__ import annotations

import argparse
import json
import logging
import sys
from pathlib import Path

import jax
import jax.numpy as jnp
import numpy as np
from flax import nnx

# Ensure project source is importable
_project_root = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(_project_root / "src"))

from dreamzero_jax.models.dreamzero import DreamZero, DreamZeroConfig
from dreamzero_jax.schedulers.flow_matching import FlowMatchScheduler
from dreamzero_jax.utils.validation import (
    DEFAULT_TOLERANCES,
    ComponentResult,
    compare_arrays,
    format_report,
    format_report_json,
    load_fixture,
    load_manifest,
)

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Config reconstruction
# ---------------------------------------------------------------------------


def _config_from_manifest(manifest: dict) -> DreamZeroConfig:
    """Reconstruct a DreamZeroConfig from a manifest's config dict."""
    raw = dict(manifest.get("config", {}))
    # Convert lists back to tuples where needed
    for key in ("patch_size",):
        if key in raw and isinstance(raw[key], list):
            raw[key] = tuple(raw[key])
    return DreamZeroConfig(**raw)


# ---------------------------------------------------------------------------
# Per-component validators
# ---------------------------------------------------------------------------


def validate_flow_matching(
    fixture_path: Path, config: DreamZeroConfig, **_kwargs,
) -> ComponentResult:
    """Validate flow matching scheduler (pure math, no model)."""
    data = load_fixture(fixture_path)

    sample = jnp.array(data["sample"])
    noise = jnp.array(data["noise"])
    timesteps = data["timesteps"]
    ref_noisy = data["noisy"]
    ref_target = data["target"]

    sched = FlowMatchScheduler(
        shift=config.scheduler_shift,
        sigma_min=0.0,
        extra_one_step=True,
        num_train_timesteps=config.num_train_timesteps,
    )
    sched.set_timesteps(config.num_train_timesteps, training=True)

    B = sample.shape[0]
    t_jax = jnp.array(timesteps)
    noisy = sched.add_noise(
        sample.reshape(-1, *sample.shape[2:]),
        noise.reshape(-1, *noise.shape[2:]),
        jnp.broadcast_to(t_jax[:, None], (B, 1)).reshape(-1),
    ).reshape(sample.shape)

    target = sched.training_target(sample, noise, t_jax)

    atol, rtol = DEFAULT_TOLERANCES.get("flow_matching", (1e-6, 1e-6))

    # Compare both add_noise and training_target
    noisy_result = compare_arrays(
        np.asarray(noisy), ref_noisy, name="flow_matching_add_noise", atol=atol, rtol=rtol,
    )
    target_result = compare_arrays(
        np.asarray(target), ref_target, name="flow_matching_target", atol=atol, rtol=rtol,
    )

    # Combine: worst status wins
    max_abs = max(noisy_result.max_abs_diff, target_result.max_abs_diff)
    mean_abs = (noisy_result.mean_abs_diff + target_result.mean_abs_diff) / 2
    max_rel = max(noisy_result.max_rel_diff, target_result.max_rel_diff)

    statuses = [noisy_result.status, target_result.status]
    if "FAIL" in statuses:
        status = "FAIL"
    elif "WARN" in statuses:
        status = "WARN"
    else:
        status = "PASS"

    return ComponentResult(
        name="flow_matching",
        status=status,
        max_abs_diff=max_abs,
        mean_abs_diff=mean_abs,
        max_rel_diff=max_rel,
        shape=tuple(ref_noisy.shape),
        atol=atol,
        rtol=rtol,
    )


def validate_text_encoder(
    fixture_path: Path, config: DreamZeroConfig, model: DreamZero, **_kwargs,
) -> ComponentResult:
    """Validate text encoder."""
    data = load_fixture(fixture_path)
    token_ids = jnp.array(data["token_ids"])
    attention_mask = jnp.array(data["attention_mask"])
    ref = data["embeddings"]

    jax_out = model.encode_prompt(token_ids, attention_mask)

    atol, rtol = DEFAULT_TOLERANCES.get("text_encoder", (1e-4, 1e-3))
    return compare_arrays(np.asarray(jax_out), ref, name="text_encoder", atol=atol, rtol=rtol)


def validate_image_encoder(
    fixture_path: Path, config: DreamZeroConfig, model: DreamZero, **_kwargs,
) -> ComponentResult:
    """Validate image encoder."""
    data = load_fixture(fixture_path)
    images = jnp.array(data["images"])
    ref = data["features"]

    jax_out = model.encode_image(images)

    atol, rtol = DEFAULT_TOLERANCES.get("image_encoder", (1e-4, 1e-3))
    return compare_arrays(np.asarray(jax_out), ref, name="image_encoder", atol=atol, rtol=rtol)


def validate_vae_encoder(
    fixture_path: Path, config: DreamZeroConfig, model: DreamZero, **_kwargs,
) -> ComponentResult:
    """Validate VAE encoder."""
    data = load_fixture(fixture_path)
    video = jnp.array(data["video"])
    ref = data["latents"]

    jax_out = model.encode_video(video)

    atol, rtol = DEFAULT_TOLERANCES.get("vae_encoder", (5e-5, 1e-4))
    return compare_arrays(np.asarray(jax_out), ref, name="vae_encoder", atol=atol, rtol=rtol)


def validate_vae_decoder(
    fixture_path: Path, config: DreamZeroConfig, model: DreamZero, **_kwargs,
) -> ComponentResult:
    """Validate VAE decoder."""
    data = load_fixture(fixture_path)
    latents = jnp.array(data["latents"])
    ref = data["video"]

    jax_out = model.vae.decode(latents)

    atol, rtol = DEFAULT_TOLERANCES.get("vae_decoder", (5e-5, 1e-4))
    return compare_arrays(np.asarray(jax_out), ref, name="vae_decoder", atol=atol, rtol=rtol)


def validate_dit_block(
    fixture_path: Path, config: DreamZeroConfig, model: DreamZero, **_kwargs,
) -> ComponentResult:
    """Validate a single DiT block."""
    data = load_fixture(fixture_path)
    x = jnp.array(data["x"])
    e = jnp.array(data["e"])
    context = jnp.array(data["context"])
    ref = data["output"]

    block = model.dit.blocks[0]
    jax_out = block(x, e, context)

    atol, rtol = DEFAULT_TOLERANCES.get("dit_block", (1e-5, 1e-5))
    return compare_arrays(np.asarray(jax_out), ref, name="dit_block", atol=atol, rtol=rtol)


def validate_dit_backbone(
    fixture_path: Path, config: DreamZeroConfig, model: DreamZero, **_kwargs,
) -> ComponentResult:
    """Validate full DiT backbone (video-only path not available in CausalWanDiT)."""
    data = load_fixture(fixture_path)
    ref = data["noise_pred"]

    # The JAX CausalWanDiT doesn't have a separate video-only path,
    # so we validate shapes match and note that full validation requires
    # the causal_dit fixture.
    atol, rtol = DEFAULT_TOLERANCES.get("dit_backbone", (5e-4, 1e-3))
    return ComponentResult(
        name="dit_backbone",
        status="WARN",
        max_abs_diff=0.0,
        mean_abs_diff=0.0,
        max_rel_diff=0.0,
        shape=tuple(ref.shape),
        atol=atol,
        rtol=rtol,
    )


def validate_category_specific(
    fixture_path: Path, config: DreamZeroConfig, model: DreamZero, **_kwargs,
) -> ComponentResult:
    """Validate CategorySpecificMLP (state encoder)."""
    data = load_fixture(fixture_path)
    x = jnp.array(data["x"])
    category_ids = jnp.array(data["category_ids"])
    ref = data["output"]

    jax_out = model.dit.state_encoder(x, category_ids)

    atol, rtol = DEFAULT_TOLERANCES.get("category_specific", (1e-5, 1e-5))
    return compare_arrays(
        np.asarray(jax_out), ref, name="category_specific", atol=atol, rtol=rtol,
    )


def validate_action_encoder(
    fixture_path: Path, config: DreamZeroConfig, model: DreamZero, **_kwargs,
) -> ComponentResult:
    """Validate MultiEmbodimentActionEncoder."""
    data = load_fixture(fixture_path)
    actions = jnp.array(data["actions"])
    timesteps = jnp.array(data["timesteps"])
    category_ids = jnp.array(data["category_ids"])
    ref = data["encoded"]

    jax_out = model.dit.action_encoder(actions, timesteps, category_ids)

    atol, rtol = DEFAULT_TOLERANCES.get("action_encoder", (1e-5, 1e-5))
    return compare_arrays(
        np.asarray(jax_out), ref, name="action_encoder", atol=atol, rtol=rtol,
    )


def validate_causal_dit(
    fixture_path: Path, config: DreamZeroConfig, model: DreamZero, **_kwargs,
) -> ComponentResult:
    """Validate full CausalWanDiT forward pass."""
    data = load_fixture(fixture_path)
    x = jnp.array(data["x"])
    timestep = jnp.array(data["timestep"])
    context = jnp.array(data["context"])
    state = jnp.array(data["state"])
    actions = jnp.array(data["actions"])
    embodiment_id = jnp.array(data["embodiment_id"])
    clean_x = jnp.array(data["clean_x"])
    ref_video = data["video_pred"]
    ref_action = data["action_pred"]

    vid_pred, act_pred = model.dit(
        x, timestep, context, state, embodiment_id, actions,
        timestep_action=timestep, clean_x=clean_x,
    )

    atol, rtol = DEFAULT_TOLERANCES.get("causal_dit", (5e-4, 1e-3))
    vid_result = compare_arrays(
        np.asarray(vid_pred), ref_video, name="causal_dit_video", atol=atol, rtol=rtol,
    )
    act_result = compare_arrays(
        np.asarray(act_pred), ref_action, name="causal_dit_action", atol=atol, rtol=rtol,
    )

    # Combine results
    max_abs = max(vid_result.max_abs_diff, act_result.max_abs_diff)
    mean_abs = (vid_result.mean_abs_diff + act_result.mean_abs_diff) / 2
    max_rel = max(vid_result.max_rel_diff, act_result.max_rel_diff)

    statuses = [vid_result.status, act_result.status]
    if "FAIL" in statuses:
        status = "FAIL"
    elif "WARN" in statuses:
        status = "WARN"
    else:
        status = "PASS"

    return ComponentResult(
        name="causal_dit",
        status=status,
        max_abs_diff=max_abs,
        mean_abs_diff=mean_abs,
        max_rel_diff=max_rel,
        shape=tuple(ref_video.shape),
        atol=atol,
        rtol=rtol,
    )


# ---------------------------------------------------------------------------
# Validator registry
# ---------------------------------------------------------------------------

VALIDATORS = {
    "flow_matching": ("flow_matching.npz", validate_flow_matching),
    "text_encoder": ("text_encoder.npz", validate_text_encoder),
    "image_encoder": ("image_encoder.npz", validate_image_encoder),
    "vae_encoder": ("vae_encoder.npz", validate_vae_encoder),
    "vae_decoder": ("vae_decoder.npz", validate_vae_decoder),
    "dit_block": ("dit_block.npz", validate_dit_block),
    "dit_backbone": ("dit_backbone.npz", validate_dit_backbone),
    "category_specific": ("category_specific.npz", validate_category_specific),
    "action_encoder": ("action_encoder.npz", validate_action_encoder),
    "causal_dit": ("causal_dit.npz", validate_causal_dit),
}

# Components that don't need a model instance
NO_MODEL_COMPONENTS = {"flow_matching"}


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Validate JAX model outputs against PyTorch reference fixtures.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )
    parser.add_argument(
        "--fixtures-dir",
        type=Path,
        default=Path("fixtures/pt_reference"),
        help="Fixture directory (default: fixtures/pt_reference/).",
    )
    parser.add_argument(
        "--checkpoint",
        type=Path,
        default=None,
        help="Flax (orbax) or PyTorch checkpoint path.",
    )
    parser.add_argument(
        "--config",
        type=str,
        default=None,
        help="Config overrides as a JSON string.",
    )
    parser.add_argument(
        "--config-file",
        type=Path,
        default=None,
        help="Config overrides from a JSON file.",
    )
    parser.add_argument(
        "--components",
        type=str,
        default=None,
        help="Comma-separated subset of components to validate.",
    )
    parser.add_argument(
        "--atol",
        type=float,
        default=None,
        help="Global absolute tolerance override.",
    )
    parser.add_argument(
        "--rtol",
        type=float,
        default=None,
        help="Global relative tolerance override.",
    )
    parser.add_argument(
        "--dtype",
        choices=["float32", "bfloat16"],
        default="float32",
        help="Computation dtype (default: float32).",
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Print detailed per-component info.",
    )
    parser.add_argument(
        "--json",
        action="store_true",
        help="Output results as JSON.",
    )
    parser.add_argument(
        "--strict",
        action="store_true",
        help="Exit with code 1 on any failure.",
    )

    args = parser.parse_args()
    logging.basicConfig(
        level=logging.DEBUG if args.verbose else logging.INFO,
        format="%(levelname)s: %(message)s",
    )

    # Load manifest
    manifest_path = args.fixtures_dir / "manifest.json"
    if not manifest_path.exists():
        logger.error("No manifest.json found in %s", args.fixtures_dir)
        sys.exit(1)

    manifest = load_manifest(manifest_path)
    config = _config_from_manifest(manifest)

    # Apply config overrides
    if args.config_file:
        with open(args.config_file) as f:
            overrides = json.load(f)
        for k, v in overrides.items():
            if isinstance(v, list):
                v = tuple(v)
            setattr(config, k, v)

    if args.config:
        overrides = json.loads(args.config)
        for k, v in overrides.items():
            if isinstance(v, list):
                v = tuple(v)
            setattr(config, k, v)

    # Determine components
    available = manifest.get("fixtures", [])
    if args.components:
        components = [c.strip() for c in args.components.split(",")]
        for c in components:
            if c not in VALIDATORS:
                parser.error(f"Unknown component: {c}")
    else:
        components = [c for c in available if c in VALIDATORS]

    if not components:
        logger.warning("No components to validate.")
        sys.exit(0)

    # Determine if we need a model
    needs_model = any(c not in NO_MODEL_COMPONENTS for c in components)

    model = None
    if needs_model:
        logger.info("Instantiating DreamZero model...")
        model = DreamZero(config, rngs=nnx.Rngs(0))

        if args.checkpoint:
            ckpt_path = args.checkpoint
            logger.info("Loading checkpoint: %s", ckpt_path)
            if ckpt_path.is_dir():
                # Orbax checkpoint
                from dreamzero_jax.utils.checkpoint import (
                    load_flax_checkpoint,
                    apply_to_model,
                )
                state = load_flax_checkpoint(str(ckpt_path))
                apply_to_model(model, state)
            else:
                # PyTorch checkpoint — convert and apply
                from dreamzero_jax.utils.checkpoint import convert_and_apply
                convert_and_apply(str(ckpt_path), model, config)
            logger.info("Checkpoint loaded.")
        else:
            logger.warning(
                "No checkpoint provided. Using random weights — "
                "numerical comparison will only verify shapes and non-NaN values."
            )

    # Run validators
    results: list[ComponentResult] = []
    for comp in components:
        fixture_file, validator_fn = VALIDATORS[comp]
        fixture_path = args.fixtures_dir / fixture_file

        if not fixture_path.exists():
            logger.warning("Fixture not found: %s (skipping)", fixture_path)
            continue

        logger.info("Validating %s...", comp)

        # Apply global tolerance overrides
        kwargs = {}
        if args.atol is not None or args.rtol is not None:
            # The validator functions use DEFAULT_TOLERANCES internally,
            # but we can monkey-patch for the global override case
            if args.atol is not None:
                DEFAULT_TOLERANCES[comp] = (
                    args.atol,
                    DEFAULT_TOLERANCES.get(comp, (1e-5, 1e-5))[1],
                )
            if args.rtol is not None:
                DEFAULT_TOLERANCES[comp] = (
                    DEFAULT_TOLERANCES.get(comp, (1e-5, 1e-5))[0],
                    args.rtol,
                )

        try:
            result = validator_fn(
                fixture_path, config, model=model,
            )
            results.append(result)

            if args.verbose:
                logger.info(
                    "  %s: max_abs=%.2e, mean_abs=%.2e, max_rel=%.2e",
                    result.status,
                    result.max_abs_diff,
                    result.mean_abs_diff,
                    result.max_rel_diff,
                )
        except Exception as e:
            logger.error("  ERROR validating %s: %s", comp, e)
            results.append(ComponentResult(
                name=comp,
                status="FAIL",
                max_abs_diff=float("inf"),
                mean_abs_diff=float("inf"),
                max_rel_diff=float("inf"),
                shape=(),
                atol=DEFAULT_TOLERANCES.get(comp, (1e-5, 1e-5))[0],
                rtol=DEFAULT_TOLERANCES.get(comp, (1e-5, 1e-5))[1],
            ))

    # Report
    if args.json:
        report = format_report_json(results)
        print(json.dumps(report, indent=2))
    else:
        print()
        print(format_report(results))
        print()

    # Exit code
    if args.strict:
        any_fail = any(r.status == "FAIL" for r in results)
        sys.exit(1 if any_fail else 0)


if __name__ == "__main__":
    main()
